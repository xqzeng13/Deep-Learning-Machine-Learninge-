### 1.?????

???**????????????????**

????????????????????????

### 2.?????

###### <u>**??????????**</u>

**#1.??dp[i] or dp[i][j] ???**
**#2.?????dp[i]=xxx;or dp[i][j]=xxx**
**#3.????dp[0],dp[1]...;dp[0][0],...?**
**#4.???????????dp[i],dp[i][j]**
**#5.????dp??**

??1 ??????

```
##TODO 1-?????(??? 0 ? 1 ?????????????????????) f(n)??
##??F(n) ,F(N):0,1,1,2,3?5,8,13,21,......F(n)
#?????

#1.??dp[i]????i??????????dp[i]
#2.?????dp[i]=dp[i-1]+dp[i-2]
#3.????dp[0]=0;dp[1]=1
#4.??????????????????????????
#5.????dp??
##?????
def dpsolution1(n):
    if n==0:
        return 0
    dp=[0]*(n+1)				##??dp??[0, 0, 0, 0]
    
    dp[0]=0
    dp[1]=1						##???
    
    for i in range (2,n+1):		##????
        dp[i]=dp[i-1]+dp[i-2]	##????
    print('fn ???? ',dp)
    return dp[n]
```

**??2** ???

```
##TODO 2-???
''''
??????????? n ????????(?????????)?
?????? 1 ? 2 ??????????????????????
????? n ???????
'''
#?????

#1.??dp[i]??????i???????
#2.?????dp[i]???????????dp[i-1],??i-1??dp[i-1]???dp[i]???1?
#                             ???dp[i-2],??i-2??dp[i-2]???dp[i]?????2????????
#                             ????i???dp[i]=dp[i-1]+dp[i-2]
#3.????dp[1]=1;dp[2]=2;dp[3]=3
#4.??????????????????????????
#5.????dp??
#?????
def dpsolution2(n):

    dp=[0]*(n+1)
    dp[1]=1
    dp[2]=2
    for i in range(3,n+1):
        dp[i] = dp[i - 1] + dp[i - 2]
    print('fn ???? ',dp)
    return dp[n]
```

**??3** ????

```
##TODO 3 ????
''''
?n?????????????w ?????i???????weight[i]???????value[i] ????????????????????????????????
'''
#???????dp??dp[i][j]

#1.??dp[i][j]???0~i????????j???????
#2.?????dp[i][j]????????1)????i??????dp[i-1][j]
								2)???i??????dp[i-1][j-weight[i]]+value[i]
								??dp[i][j]=max{dp[i-1][j],dp[i-1][j-weight[i]]+value[i]}
	
#3.???????????????????dp[:][0]=0
#4.???????
				?????????????????????????????
#5.????dp??

##?????
def test_2_wei_bag_problem1():
    weight = [1, 3, 4]
    value = [15, 20, 30]
    bagweight = 4

    # ????
    dp = [[0] * (bagweight + 1) for _ in range(len(weight))] #????dp??

    # ???
    for j in range(weight[0], bagweight + 1):#???dp??
        dp[0][j] = value[0]

    # weight???????????
    for i in range(1, len(weight)):  # ????
        for j in range(bagweight + 1):  # ??????
            if j < weight[i]:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])#????

    print(dp[len(weight) - 1][bagweight])
```



**??4** ??????

```
##TODO 4 ????
''''
????????? m x n ?????? ???????????“Start” ??
???????????????????????????????????????“Finish”??
??????????????????????????????????
'''
#???????dp??dp[i][j]

#1.??dp[i][j]???????0 ?0?????(i, j) ?dp[i][j]??????
#2.?????dp[i][j]?dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
	#????????????????(i, j)???????????????????????0?
	
#3.??????????????????????(0, 0)????(i, 0)??????????dp[i][0]???1?dp[0][j]???????(i, 0) ?????????????????????????????????????dp[i][0]???????0???(0, j)????????
#4.????????????dp[i][j] = dp[i - 1][j] + dp[i][j - 1] ??????????????????????????dp[i][j]????dp[i - 1][j] ? dp[i][j - 1]???????
#5.????dp??

##?????
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid):
        m = len(obstacleGrid)
        n = len(obstacleGrid[0])
        if obstacleGrid[m - 1][n - 1] == 1 or obstacleGrid[0][0] == 1:
            return 0
        dp = [[0] * n for _ in range(m)]
        for i in range(m):
            if obstacleGrid[i][0] == 0:  # ????????????????????0
                dp[i][0] = 1
            else:
                break
        for j in range(n):
            if obstacleGrid[0][j] == 0:
                dp[0][j] = 1
            else:
                break
        for i in range(1, m):
            for j in range(1, n):
                if obstacleGrid[i][j] == 1:
                    continue
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        return dp[m - 1][n - 1]
```

### 3.?????

###### <u>**????????**</u>

```
void backtracking(??) {
    if (????) {
        ????;
        return;
    }

    for (????????????????????????????) {
        ????;
        backtracking(???????); // ??
        ?????????
    }
}
```

**<u>??????????????????????????????????????</u>**

**#1.?????????**
**#2.??????**
**#3.????????**
**??1** ???????????

```
''
????????????
?????????????? 2-9 ???????????????????????? ???? ??????????????????????????? 1 ????????
''
class Solution:
    def __init__(self):
        self.letterMap = [
            "",     # 0
            "",     # 1
            "abc",  # 2
            "def",  # 3
            "ghi",  # 4
            "jkl",  # 5
            "mno",  # 6
            "pqrs", # 7
            "tuv",  # 8
            "wxyz"  # 9
        ]
        self.result = []
        self.s = ""
    #????
    def backtracking(self,digits,idex):
        if idex==len(digits):         #????
            self.result.append(self.s)
            return
        digit=int(digits[idex])       #??????
        num_s=self.letterMap[digit]
        for i in range(len(num_s)):   #????????????
            self.s+=num_s[i]
            self.backtracking(digits,idex+1)
            self.s=self.s[:-1]##???????????’ad‘??’a'???????
    #?????       
    def letterCombinations(self, digits: str) -> List[str]:
        if len(digits)==0:
            return self.result
        self.backtracking(digits,0)
        return self.result
#????
# digits = "23"
# result=Solution().letterCombinations(digits)###??Solution?????
# print(result)
```

**??2** ????

```
''
????????????
????????????????? candidates ?????? target ??? candidates ?????????? target ????candidates ???????????????? ?? ??? ????????????
''
#??????????????????idex,????Sum,????path,????
#?????????????
class Solution:
    def backtracing(self,candidates,target,idex,Sum,path,result):#1.????????
        if Sum>target:#2.??????
            return
        if Sum==target:
            result.append(path[:])
            return
        for i in range (idex,len(candidates)):
        ###?????? [[1,1,6],[1,2,5],[1,7],[1,2,5],[1,7],[2,6]]
            if candidates[i]==candidates[i-1] and i>idex:##???????????????
                continue
            Sum+=candidates[i]
            path.append(candidates[i])
            self.backtracing(candidates,target,i+1,Sum,path,result)##??idex?i??
            Sum-=candidates[i]##?? ?????????????????
            path.pop()#?? ?????????????????
            
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        result=[]
        candidates=sorted(candidates)#??????????????????[1,7]?[7,1]???
        self.backtracing(candidates,target,0,0,[],result)#????????
        return result
#????
# digits = "23"
# result=Solution().letterCombinations(digits)###??Solution?????
# print(result)
```

